# ?Flexbox

Flexbox был представлен в 2009 году как новая система макетирования с целью помочь нам создавать адаптивные веб-страницы и легко организовывать наши элементы, и с тех пор он привлекает все больше и больше внимания.

До Flexbox Layout module существовало четыре режима макета:

* __Block__, для разделов веб-страницы
* __Inline__, для текста
* __Table__, для двумерных табличных данных.
* __Positioned__, для явного позиционирования элемента.

### Создание flex-контейнера

Для создания flex-контейнера необходимо присвоить его стилевому свойству `display` одно из двух значений: `flex` или `inline-flex`.

Если значение `flex` определяет контейнер как блочный элемент, то значение `inline-flex` определяет элемент как строчный (`inline`).

В частности, в первом случае flex-контейнер растягивается по ширине страницы, а во втором случае занимает именно столько места, сколько необходимо для flex-элементов.

### Направление `flex-direction`

Для управления направлением элементов CSS3 предоставляет свойство `flex-direction`. Оно определяет направление элементов и может принимать следующие значения:

* `row`: значение по умолчанию, при котором элементы располагаются в виде строки слева направо
* `row-reverse`: элементы также располагаются в виде стоки только в обратном порядке справа налево
* `column`: элементы располагаются в столбик сверху вниз
* `column-reverse`: элементы располагаются в столбик в обратном порядке снизу вверх

### `flex-wrap`

Свойство `flex-wrap` определяет, будет ли flex-контейнер несколько рядов элементов (строк или столбцов) в случае если его размеры недостаточны, чтобы вместить в один ряд все элементы. Это свойство может принимать следующие значения:

* `nowrap`: значение по умолчанию, которое определяет flex-контейнер, где все элементы раполагаются в одну строку (при расположении в виде строк) или один столбец (при расположении в столбик)
* `wrap`: если элементы не помещаются во flex-контейнер, то создает дополнительные ряды в контейнере для размещения элементов. При расположении в виде строки содаются дополнительные строки, а при расположении в виде столбца добавляются дополнительные столбцы
* `wrap-reverse`: то же самое, что и значение `wrap`, только элементы располагаются в обратном порядке

### `flex-flow`. Порядок элементов

Свойство `flex-flow` позволяет установить значения сразу для обоих свойств `flex-direction` и `flex-wrap`. Оно имеет следующий формальный синтаксис:

~~~
flex-flow: [flex-direction] [flex-wrap]
~~~

Причем второе свойство - `flex-wrap` можно в принципе опустить, тогда для него будет использоваться значение по умолчанию - `nowrap`.

~~~
flex-flow: <flex-direction> || <flex-wrap>;
~~~

Вы можете указать одно или два значения независимо от порядка.

### Свойство `order`

Свойство `order` позволяет установить группу для flex-элемента, позволяя тем самым переопределить его позицию внутри flex-контейнера. В качестве значения свойство принимает числовой порядок группы. К одной группе может принадлежать несколько элементов.

Например, элементы в группе `0` располагаются перед элементами с группой `1`, а элементы с группой `1` располагаются перед элементами с группой `2` и так далее.

По умолчанию если у элементов явным образом не указано свойство `order`, то оно имеет значение `0`.

### Выравнивание элементов. `justify-content`

`justify-content` выравнивает элементы вдоль основной оси - main axis (при расположении в виде строки по горизонтали, при расположении в виде столбца - по вертикали) и принимает следующие значения:

* `flex-start`: значение по умолчанию, при котором первый элемент выравнивается по левому краю контейнера(при расположении в виде строки) или по верху (при расположении в виде столбца), за ним располагается второй элемент и так далее.
* `flex-end`: последний элемент выравнивается по правому краю (при расположении в виде строки) или по низу (при расположении в виде столбца) контейнера, за ним выравнивается предпоследний элемент и так далее
* `center`: элементы выравниваются по центру
* `space-between`: если в стоке только один элемент или элементы выходят за границы flex-контейнера, то данное значение аналогично `flex-start`. В остальных случаях первый элемент выравнивается по левому краю (при расположении в виде строки) или по верху (при расположении в виде столбца), а последний элемент - по правому краю контейнера (при расположении в виде строки) или по низу (при расположении в виде столбца). Все оставшееся пространство между ними равным образом распределяется между остальными элементами
* `space-around`: если в строке только один элемент или элементы выходят за пределы контейнера, то его действие аналогично значению `center`. В ином случае элементы равным образом распределяют пространство между левым и правым краем контейнера, а расстояние между первым и последним элементом и границами контейнера составляет половину расстояния между элементами.

### Выравнивание элементов. `align-items` и `align-self`

Свойство `align-items` также выравнивает элементы, но уже по поперечной оси (cross axis) (при расположении в виде строки по вертикали, при расположении в виде столбца - по горизонтали). Это свойство может принимать следующие значения:

* `stretch`: значение по умолчанию, при котором flex-элементы растягиваются по всей высоте (при расположении в строку) или по всей ширине (при расположении в столбик) flex-контейнера
* `flex-start`: элементы выравниваются по верхнему краю (при расположении в строку) или по левому краю (при расположении в столбик) flex-контейнера
* `flex-end`: элементы выравниваются по нижнему краю (при расположении в строку) или по правому краю (при расположении в столбик) flex-контейнера
* `center`: элементы выравниваются по центру flex-контейнера
* `baseline`: элементы выравниваются в соответствии со своей базовой линией

Свойство `align-self` позволяет переопределить значение свойства `align-items` для одного элемента. Оно может принимать все те же значения плюс значение `"auto"`:

* `auto`: значение по умолчанию, при котором элемент получает значение от свойства `align-items`, которое определено в flex-контейнере. Если в контейнере такой стиль не определен, то применяется значение `stretch`.
* `stretch`
* `flex-start`
* `flex-end`
* `center`
* `baseline`

### Выравнивание строк и столбцов. `align-content`

Свойство `align-content` управляет выравниванием рядов (строк и столбцов) во flex-контейнере и поэтому применяется, если свойство `flex-wrap` имеет значение `wrap` или `wrap-reverse`. Свойство `align-content` может иметь следующие значения:

* `stretch`: значение по умолчанию, при котором строки (столбцы) растягиваются, занимая все свободное место
* `flex-start`: строки (столбцы) выравниваются по началу контейнера (для строк - это верхний край, для столбцов - это левый край контейнера)
* `flex-end`: строки (столбцы) выравниваются по концу контейнера (строки - по нижнему краю, столбцы - по правому краю)
* `center`: строки (столбцы) позиционируются по центру контейнера
* `space-between`: строки (столбцы) равномерно распределяются по контейнеру, а между ними образуются одинаковые отступы. Если же имеющегося в контейнере места недостаточно, то действует аналогично значению `flex-start`
* `space-around`: строки (столбцы) равным образом распределяют пространство контейнера, а растояние между первой и последней строкой (столбцом) и границами контейнера составляет половину расстояния между соседними строками (столбцами).

### Управление элементами. `flex-basis`, `flex-shrink` и `flex-grow`

Кроме свойств, устанавливающих выравнивание элементов относительно границ flex-контейнера, есть еще три свойства, которые позволяют управлять элементами:

* `flex-basis`: определяет начальный размер flex-элемента
* `flex-shrink`: определяет, как flex-элемент будет уменьшаться относительно других flex-элементов во flex-контейнере
* `flex-grow`: определяет, как flex-элемент будет увеличиваться относительно других flex-элементов во flex-контейнере

#### `flex-basis`

Flex-контейнер может увеличиваться или уменьшаться вдоль своей центральной оси, например, при изменении размеров браузера, если контейнер имеет нефиксированные размеры. И вместе с контейнером также могут увеличиваться и уменьшаться его flex-элементы. Свойство `flex-basis` определяет начальный размер flex-элемента до того, как он начнет изменять размер, подстраиваясь под размеры flex-контейнера.

Это свойство может принимать следующие значения:

* `auto`: начальный размер flex-элемента устанавливается автоматически
* `content`: размер flex-элемента определяется по его содержимому, в то же время это значение поддерживается не всеми современными браузерами, поэтому его пока стоит избегать
* числовое значение: мы можем установить конкретное числовое значение для размеров элемента

~~~
.item1 { background-color: #675BA7; flex-basis: auto; width:150px; }
.item2 { background-color: #9BC850; flex-basis: auto; width:auto; }
.item3 { background-color: #A62E5C; flex-basis: 200px;width:150px; }
~~~

У первого элемента у свойства `flex-basis` установлено значение `auto`. Поэтому первый элемент в качестве реального значения для ширины будет использовать значение свойства `width`.

У второго элемента у свойства `flex-basis` установлено значение `auto`, однако и свойство `width` имеет значение auto. Поэтому реальная ширина элемента будет устанавливаться по его содержимому.

У третьего элемента свойство `flex-basis` имеет конкретное значение, которое и используется. А свойство `width` в этом случае уже не играет никакой роли.

#### `flex-shrink`

Если flex-контейнер имеет недостаточно места для размещения элемента, то дальнейшее поведение этого элемента мы можем определить с помощью свойства `flex-shrink`. Оно указывает, как элемент будет усекаться относительно других элементов.

В качестве значения свойство принимает число. По умолчанию его значение `1`.

~~~
.item1 { background-color: #675BA7; flex-basis: 200px; flex-shrink:1; }
.item2 { background-color: #9BC850; flex-basis: 200px; flex-shrink:2; }
.item3 { background-color: #A62E5C; flex-basis: 200px; flex-shrink:3; }
~~~

В данном случае начальная ширина каждого элемента равна `200px`, то есть совокупная ширина составляет `600px`. Однако ширина flex-контейнера составляет всего `400px`. То есть размер контейнера недостаточен для вмещения в него элементов, поэтому в действие вступает свойство `flex-shrink`, которое определено у элементов.

Для усечения элементов браузер вычисляет коэффициент усечения (shrinkage factor). Он вычисляется путем перемножения значения свойства `flex-basis` на `flex-shrink`. Таким образом, для трех элементов мы получим следующие вычисления:

~~~
// первый элемент
200px * 1 = 200
// второй элемент
200px * 2 = 400
// третий элемент
200px * 3 = 600
~~~

Таким образом, мы получаем, что для второго элемента коэффициент усечения в два раза больше, чем коэффициент для первого элемента. А для третьего элемента коэффициент больше в три раза, чем у первого элемента. Поэтому в итоге первый элемент при усечении будет в три раза больше, чем третий и в два раза больше, чем второй.

#### `flex-grow`

Свойство `flex-grow` управляет расширением элементов, если во flex-контейнере есть дополнительное место. Данное свойство во многом похоже на свойство `flex-shrink` за тем исключением, что работает в сторону увеличения элементов.

В качестве значения свойство `flex-grow` принимает положительное число, которое указывает, во сколько раз элемент будет увеличиваться относительно других элементов при увеличении размеров flex-контейнера. По умолчанию свойство `flex-grow` равно `0`.

~~~
.item1 { background-color: #675BA7; flex-grow:0; }
.item2 { background-color: #9BC850; flex-grow:1; }
.item3 { background-color: #A62E5C; flex-grow:2; }
~~~

Итак, для каждого элемента есть базовые начальные размеры. Здесь явным образом размеры для элементов не указаны, поэтому размер каждого элемента в данном случае будет складываться из размеров внутреннего содержимого, к которым добавляются внутренние отступы.

По мере растягивания контейнера будут увеличиваться элементы в соответствии со свойством `flex-grow`, которое указано для каждого элемента. Пространство, на которое растягивается контейнер, считается дополнительным пространством.

Так как у первого элемента свойство `flex-grow` равно `0`, то первый элемент будет иметь константные постоянные размеры. У второго элемента `flex-grow` равно `1`, а третьего - `2`. Таким образом, в сумме они дадут `0 + 1 + 2 = 3`. Поэтому второй элемент будет увеличиваться на `1/3` дополнительного пространства, на которое растягивается контейнер, а третий элемент будет получать `2/3` дополнительного пространства.

#### Свойство `flex`

Свойство flex является объединением свойств flex-basis, flex-shrink и flex-grow и имеет следующий формальный синтаксис:

~~~
flex: [flex-grow] [flex-shrink] [flex-basis]
~~~

По умолчанию свойство `flex` имеет значение `0 1 auto`.

Кроме конкретных значений для каждого из подсвойств мы можем задать для свойства `flex` одно из трех общих значений:

* `flex: none`: эквивалентно значению `0 0 auto`, при котором flex-элемент не растягивается и не усекается при увеличении и уменьшении контейнера
* `flex: auto`: эквивалентно значению `1 1 auto`
* `flex: initial`: эквивалентно значению `0 1 auto`

### `row-gap` и `column-gap`

`row-gap` устанавливает размер промежутка между строками элемента.

`column-gap` устанавливает размер промежутка между столбцами элемента.

`gap` — это сокращение от `row-gap` и `column-gap`.

`gap` принимает одно или два значения:

* Одно значение задает `row-gap` и `column-gap` одно и то же значение.
* Если используются два значения, первое устанавливает `row-gap`, а второе — `column-gap`.

Два свойства CSS `justify-items` и `justify-self` отсутствуют в спецификации Flexbox. Причина, по которой `justify-items` и `justify-self` не включены в спецификацию Flexbox, заключается в том, что они не нужны. В Flexbox `justify-content` уже предоставляет мощный и гибкий способ выравнивания элементов по главной оси контейнера. Кроме того, `align-items` можно использовать для выравнивания элементов по поперечной оси.

> https://flexboxfroggy.com/ - a game for learning CSS flexbox.

> https://css-tricks.com/snippets/css/a-guide-to-flexbox/ - полное руководство по Flexbox.
